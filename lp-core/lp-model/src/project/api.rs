use crate::nodes::{NodeConfig, NodeHandle, NodeKind};
use crate::nodes::{
    fixture::FixtureConfig, output::OutputConfig, shader::ShaderConfig, texture::TextureConfig,
};
// Serializable wrappers are generated by the macro in each state module
use crate::nodes::fixture::state::SerializableFixtureState;
use crate::nodes::output::state::SerializableOutputState;
use crate::nodes::shader::state::SerializableShaderState;
use crate::nodes::texture::state::SerializableTextureState;
use crate::path::LpPathBuf;
use crate::project::FrameId;
use alloc::boxed::Box;
use alloc::collections::BTreeMap;
use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;
use serde::{Deserialize, Serialize, Serializer, ser::SerializeStruct};

/// Node specifier for API requests
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ApiNodeSpecifier {
    /// No nodes
    None,
    /// All nodes
    All,
    /// Specific handles
    ByHandles(Vec<NodeHandle>),
}

/// Project request from client
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ProjectRequest {
    /// Get changes since a frame
    GetChanges {
        /// Last frame client synced
        since_frame: FrameId,
        /// Which nodes need full state
        detail_specifier: ApiNodeSpecifier,
    },
}

/// Project response from server
///
/// Note: Cannot implement Clone because NodeDetail contains trait object.
///
/// TODO: Serialization is disabled in ServerResponse because ProjectResponse contains
/// `NodeDetail` which includes `Box<dyn NodeConfig>` (a trait object) that cannot be
/// serialized directly with serde. See `lp-model/src/server/api.rs::ServerResponse`
/// for the disabled variant.
#[derive(Debug)]
pub enum ProjectResponse {
    /// Changes response
    GetChanges {
        /// Current frame ID
        current_frame: FrameId,
        /// Frame ID to compare against (since_frame from request)
        since_frame: FrameId,
        /// All current node handles (for pruning removed nodes)
        node_handles: Vec<NodeHandle>,
        /// Changed nodes since since_frame
        node_changes: Vec<NodeChange>,
        /// Full detail for requested nodes
        node_details: BTreeMap<NodeHandle, NodeDetail>,
        /// Theoretical FPS based on frame processing time (None if not available)
        theoretical_fps: Option<f32>,
    },
}

/// Node change notification
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeChange {
    /// New node created
    Created {
        handle: NodeHandle,
        path: LpPathBuf,
        kind: NodeKind,
    },
    /// Config updated
    ConfigUpdated {
        handle: NodeHandle,
        config_ver: FrameId,
    },
    /// State updated
    StateUpdated {
        handle: NodeHandle,
        state_ver: FrameId,
    },
    /// Status changed
    StatusChanged {
        handle: NodeHandle,
        status: NodeStatus,
    },
    /// Node removed
    Removed { handle: NodeHandle },
}

/// Node status
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum NodeStatus {
    /// Created but not yet initialized
    Created,
    /// Error initializing the node
    InitError(String),
    /// Node is running normally
    Ok,
    /// Node is running, but something is wrong
    Warn(String),
    /// Node cannot run
    Error(String),
}

/// Node detail - full config + state
///
/// Note: Cannot implement Clone/PartialEq/Eq because config is a trait object.
///
/// TODO: Serialization is blocked because `Box<dyn NodeConfig>` cannot be serialized
/// directly with serde. This prevents ProjectResponse (which contains NodeDetail) from
/// being serialized in ServerResponse.
///
/// Options for future implementation:
/// 1. Create a serializable wrapper enum that matches on NodeKind and serializes concrete types
/// 2. Implement custom Serialize/Deserialize that dispatches based on NodeKind
/// 3. Refactor to use an enum instead of trait objects (breaking change)
///
/// See: `lp-model/src/server/api.rs::ServerResponse` for where this blocks serialization
#[derive(Debug)]
pub struct NodeDetail {
    pub path: LpPathBuf,
    pub config: Box<dyn NodeConfig>, // TODO: Needs serialization support (see struct docs)
    pub state: NodeState,            // External state only
}

/// Node state - external state (shared with clients)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum NodeState {
    Texture(crate::nodes::texture::TextureState),
    Shader(crate::nodes::shader::ShaderState),
    Output(crate::nodes::output::OutputState),
    Fixture(crate::nodes::fixture::FixtureState),
}

impl NodeState {
    /// Merge fields from a partial update into this state
    ///
    /// Only fields that are present in `other` (non-default values) are merged.
    /// Fields not present in the partial update are preserved from `self`.
    ///
    /// # Panics
    ///
    /// Panics if `self` and `other` are different variants (should not happen in practice).
    pub fn merge_from(&mut self, other: &Self, frame_id: FrameId) {
        match self {
            NodeState::Texture(self_state) => {
                if let NodeState::Texture(other_state) = other {
                    self_state.merge_from(other_state, frame_id);
                } else {
                    // Mismatched variants shouldn't happen, but handle gracefully by replacing
                    *self = other.clone();
                }
            }
            NodeState::Shader(self_state) => {
                if let NodeState::Shader(other_state) = other {
                    self_state.merge_from(other_state, frame_id);
                } else {
                    *self = other.clone();
                }
            }
            NodeState::Output(self_state) => {
                if let NodeState::Output(other_state) = other {
                    self_state.merge_from(other_state, frame_id);
                } else {
                    *self = other.clone();
                }
            }
            NodeState::Fixture(self_state) => {
                if let NodeState::Fixture(other_state) = other {
                    self_state.merge_from(other_state, frame_id);
                } else {
                    *self = other.clone();
                }
            }
        }
    }
}

/// Serializable wrapper for NodeDetail
///
/// This enum allows NodeDetail (which contains Box<dyn NodeConfig>) to be serialized
/// by matching on NodeKind and serializing concrete config types.
///
/// The state field is serialized with context-aware serialization that only includes
/// fields changed since since_frame (handled by SerializableProjectResponse).
///
/// Note: When serialized standalone (e.g., in tests), all fields are serialized.
/// When serialized as part of SerializableProjectResponse, partial serialization
/// is used based on since_frame.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum SerializableNodeDetail {
    /// Texture node detail
    Texture {
        path: LpPathBuf,
        config: TextureConfig,
        state: NodeState,
    },
    /// Shader node detail
    Shader {
        path: LpPathBuf,
        config: ShaderConfig,
        state: NodeState,
    },
    /// Output node detail
    Output {
        path: LpPathBuf,
        config: OutputConfig,
        state: NodeState,
    },
    /// Fixture node detail
    Fixture {
        path: LpPathBuf,
        config: FixtureConfig,
        state: NodeState,
    },
}

/// Serializable wrapper for ProjectResponse
///
/// This enum allows ProjectResponse (which contains NodeDetail) to be serialized
/// by using SerializableNodeDetail instead of NodeDetail.
///
/// Note: node_details uses Vec instead of BTreeMap because JSON map keys must be strings,
/// and tuple structs don't deserialize correctly from string keys.
///
/// Uses custom Serialize implementation to enable context-aware state serialization
/// that only includes fields changed since since_frame.
///
/// Note: Deserialization uses default externally tagged enum format.
/// The custom serialization creates the same format, so default deserialization works.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub enum SerializableProjectResponse {
    /// Changes response
    GetChanges {
        /// Current frame ID
        current_frame: FrameId,
        /// Frame ID to compare against (since_frame from request)
        since_frame: FrameId,
        /// All current node handles (for pruning removed nodes)
        node_handles: Vec<NodeHandle>,
        /// Changed nodes since since_frame
        node_changes: Vec<NodeChange>,
        /// Full detail for requested nodes (serializable)
        /// Uses Vec instead of BTreeMap for JSON compatibility
        node_details: Vec<(NodeHandle, SerializableNodeDetail)>,
        /// Theoretical FPS based on frame processing time (None if not available)
        theoretical_fps: Option<f32>,
    },
}

// Helper struct to serialize SerializableNodeDetail with since_frame context
struct SerializableNodeDetailWithFrame<'a> {
    detail: &'a SerializableNodeDetail,
    since_frame: FrameId,
}

impl<'a> Serialize for SerializableNodeDetailWithFrame<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self.detail {
            SerializableNodeDetail::Texture {
                path,
                config,
                state,
            } => {
                let mut s = serializer.serialize_struct("Texture", 3)?;
                s.serialize_field("path", path)?;
                s.serialize_field("config", config)?;
                match state {
                    NodeState::Texture(texture_state) => {
                        let serializable_state =
                            SerializableTextureState::new(texture_state, self.since_frame);
                        s.serialize_field("state", &serializable_state)?;
                    }
                    _ => return Err(serde::ser::Error::custom("State kind mismatch")),
                }
                s.end()
            }
            SerializableNodeDetail::Shader {
                path,
                config,
                state,
            } => {
                let mut s = serializer.serialize_struct("Shader", 3)?;
                s.serialize_field("path", path)?;
                s.serialize_field("config", config)?;
                match state {
                    NodeState::Shader(shader_state) => {
                        let serializable_state =
                            SerializableShaderState::new(shader_state, self.since_frame);
                        s.serialize_field("state", &serializable_state)?;
                    }
                    _ => return Err(serde::ser::Error::custom("State kind mismatch")),
                }
                s.end()
            }
            SerializableNodeDetail::Output {
                path,
                config,
                state,
            } => {
                let mut s = serializer.serialize_struct("Output", 3)?;
                s.serialize_field("path", path)?;
                s.serialize_field("config", config)?;
                match state {
                    NodeState::Output(output_state) => {
                        let serializable_state =
                            SerializableOutputState::new(output_state, self.since_frame);
                        s.serialize_field("state", &serializable_state)?;
                    }
                    _ => return Err(serde::ser::Error::custom("State kind mismatch")),
                }
                s.end()
            }
            SerializableNodeDetail::Fixture {
                path,
                config,
                state,
            } => {
                let mut s = serializer.serialize_struct("Fixture", 3)?;
                s.serialize_field("path", path)?;
                s.serialize_field("config", config)?;
                match state {
                    NodeState::Fixture(fixture_state) => {
                        let serializable_state =
                            SerializableFixtureState::new(fixture_state, self.since_frame);
                        s.serialize_field("state", &serializable_state)?;
                    }
                    _ => return Err(serde::ser::Error::custom("State kind mismatch")),
                }
                s.end()
            }
        }
    }
}

// Helper struct for serializing GetChanges variant with context-aware state serialization
struct GetChangesSerializer<'a> {
    current_frame: &'a FrameId,
    since_frame: &'a FrameId,
    node_handles: &'a Vec<NodeHandle>,
    node_changes: &'a Vec<NodeChange>,
    node_details: &'a Vec<(NodeHandle, SerializableNodeDetail)>,
    theoretical_fps: &'a Option<f32>,
}

impl<'a> Serialize for GetChangesSerializer<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("GetChanges", 6)?;
        state.serialize_field("current_frame", self.current_frame)?;
        state.serialize_field("since_frame", self.since_frame)?;
        state.serialize_field("node_handles", self.node_handles)?;
        state.serialize_field("node_changes", self.node_changes)?;

        // Serialize node_details with context-aware state serialization
        struct TupleSerializer<'b, T1: Serialize, T2: Serialize> {
            item1: &'b T1,
            item2: &'b T2,
        }
        impl<'b, T1: Serialize, T2: Serialize> Serialize for TupleSerializer<'b, T1, T2> {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                use serde::ser::SerializeTuple;
                let mut tuple = serializer.serialize_tuple(2)?;
                tuple.serialize_element(self.item1)?;
                tuple.serialize_element(self.item2)?;
                tuple.end()
            }
        }
        // Collect SerializableNodeDetailWithFrame instances first (to avoid lifetime issues)
        let detail_wrappers: Vec<_> = self
            .node_details
            .iter()
            .map(|(_, detail)| SerializableNodeDetailWithFrame {
                detail,
                since_frame: *self.since_frame,
            })
            .collect();
        // Then create tuples referencing the wrappers
        let serializable_tuples: Vec<_> = self
            .node_details
            .iter()
            .zip(detail_wrappers.iter())
            .map(|((handle, _), wrapper)| TupleSerializer {
                item1: handle,
                item2: wrapper,
            })
            .collect();
        state.serialize_field("node_details", &serializable_tuples)?;
        state.serialize_field("theoretical_fps", self.theoretical_fps)?;
        state.end()
    }
}

impl Serialize for SerializableProjectResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            SerializableProjectResponse::GetChanges {
                current_frame,
                since_frame,
                node_handles,
                node_changes,
                node_details,
                theoretical_fps,
            } => {
                // Serialize as externally tagged enum: {"GetChanges": {...}}
                // Use a helper struct that will be serialized as the enum variant content
                let variant_serializer = GetChangesSerializer {
                    current_frame,
                    since_frame,
                    node_handles,
                    node_changes,
                    node_details,
                    theoretical_fps,
                };
                // Serialize as map with single entry for enum variant
                use serde::ser::SerializeMap;
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("GetChanges", &variant_serializer)?;
                map.end()
            }
        }
    }
}

impl NodeDetail {
    /// Convert NodeDetail to SerializableNodeDetail
    ///
    /// Downcasts the Box<dyn NodeConfig> to the concrete config type based on NodeKind.
    /// The state is stored as NodeState; context-aware serialization happens during
    /// SerializableProjectResponse serialization.
    pub fn to_serializable(&self) -> Result<SerializableNodeDetail, String> {
        let kind = self.config.kind();
        match kind {
            NodeKind::Texture => {
                let config = self
                    .config
                    .as_any()
                    .downcast_ref::<TextureConfig>()
                    .ok_or_else(|| format!("Failed to downcast to TextureConfig"))?;
                Ok(SerializableNodeDetail::Texture {
                    path: self.path.clone(),
                    config: config.clone(),
                    state: self.state.clone(),
                })
            }
            NodeKind::Shader => {
                let config = self
                    .config
                    .as_any()
                    .downcast_ref::<ShaderConfig>()
                    .ok_or_else(|| format!("Failed to downcast to ShaderConfig"))?;
                Ok(SerializableNodeDetail::Shader {
                    path: self.path.clone(),
                    config: config.clone(),
                    state: self.state.clone(),
                })
            }
            NodeKind::Output => {
                let config = self
                    .config
                    .as_any()
                    .downcast_ref::<OutputConfig>()
                    .ok_or_else(|| format!("Failed to downcast to OutputConfig"))?;
                Ok(SerializableNodeDetail::Output {
                    path: self.path.clone(),
                    config: config.clone(),
                    state: self.state.clone(),
                })
            }
            NodeKind::Fixture => {
                let config = self
                    .config
                    .as_any()
                    .downcast_ref::<FixtureConfig>()
                    .ok_or_else(|| format!("Failed to downcast to FixtureConfig"))?;
                Ok(SerializableNodeDetail::Fixture {
                    path: self.path.clone(),
                    config: config.clone(),
                    state: self.state.clone(),
                })
            }
        }
    }
}

impl ProjectResponse {
    /// Convert ProjectResponse to SerializableProjectResponse
    ///
    /// Converts all NodeDetail entries to SerializableNodeDetail with since_frame context.
    pub fn to_serializable(&self) -> Result<SerializableProjectResponse, String> {
        match self {
            ProjectResponse::GetChanges {
                current_frame,
                since_frame,
                node_handles,
                node_changes,
                node_details,
                theoretical_fps,
            } => {
                let mut serializable_details = Vec::new();
                for (handle, detail) in node_details {
                    let serializable_detail = detail.to_serializable()?;
                    serializable_details.push((*handle, serializable_detail));
                }
                Ok(SerializableProjectResponse::GetChanges {
                    current_frame: *current_frame,
                    since_frame: *since_frame,
                    node_handles: node_handles.clone(),
                    node_changes: node_changes.clone(),
                    node_details: serializable_details,
                    theoretical_fps: *theoretical_fps,
                })
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nodes::texture::TextureFormat;
    use alloc::{string::ToString, vec};

    #[test]
    fn test_api_node_specifier() {
        let spec = ApiNodeSpecifier::None;
        assert_eq!(spec, ApiNodeSpecifier::None);

        let spec = ApiNodeSpecifier::All;
        assert_eq!(spec, ApiNodeSpecifier::All);

        let spec = ApiNodeSpecifier::ByHandles(vec![NodeHandle::new(1), NodeHandle::new(2)]);
        match spec {
            ApiNodeSpecifier::ByHandles(handles) => {
                assert_eq!(handles.len(), 2);
            }
            _ => panic!("Expected ByHandles"),
        }
    }

    #[test]
    fn test_project_request() {
        let request = ProjectRequest::GetChanges {
            since_frame: FrameId::default(),
            detail_specifier: ApiNodeSpecifier::All,
        };
        match request {
            ProjectRequest::GetChanges {
                since_frame,
                detail_specifier,
            } => {
                assert_eq!(since_frame, FrameId::default());
                assert_eq!(detail_specifier, ApiNodeSpecifier::All);
            }
        }
    }

    #[test]
    fn test_node_status() {
        let status = NodeStatus::Created;
        assert_eq!(status, NodeStatus::Created);

        let status = NodeStatus::InitError("test error".to_string());
        match status {
            NodeStatus::InitError(msg) => assert_eq!(msg, "test error"),
            _ => panic!("Expected InitError"),
        }
    }

    #[test]
    fn test_node_state() {
        use crate::project::FrameId;
        let mut tex_state = crate::nodes::texture::TextureState::new(FrameId::default());
        tex_state
            .texture_data
            .set(FrameId::default(), vec![0, 1, 2, 3]);
        tex_state.width.set(FrameId::default(), 2);
        tex_state.height.set(FrameId::default(), 2);
        tex_state
            .format
            .set(FrameId::default(), TextureFormat::Rgba16);
        let state = NodeState::Texture(tex_state);
        match state {
            NodeState::Texture(tex_state) => {
                assert_eq!(tex_state.texture_data.value().len(), 4);
            }
            _ => panic!("Expected Texture state"),
        }
    }

    #[test]
    fn test_node_detail_to_serializable_texture() {
        use crate::nodes::texture::TextureConfig;
        use crate::project::FrameId;
        let mut tex_state = crate::nodes::texture::TextureState::new(FrameId::default());
        tex_state
            .texture_data
            .set(FrameId::default(), vec![0, 1, 2, 3]);
        tex_state.width.set(FrameId::default(), 2);
        tex_state.height.set(FrameId::default(), 2);
        tex_state
            .format
            .set(FrameId::default(), TextureFormat::Rgba16);
        let detail = NodeDetail {
            path: LpPathBuf::from("/src/texture.texture"),
            config: Box::new(TextureConfig {
                width: 100,
                height: 200,
            }),
            state: NodeState::Texture(tex_state),
        };
        let serializable = detail.to_serializable().unwrap();
        match serializable {
            SerializableNodeDetail::Texture {
                path,
                config,
                state,
            } => {
                assert_eq!(path.as_str(), "/src/texture.texture");
                assert_eq!(config.width, 100);
                assert_eq!(config.height, 200);
                assert!(matches!(state, NodeState::Texture(_)));
            }
            _ => panic!("Expected Texture variant"),
        }
    }

    #[test]
    fn test_node_detail_to_serializable_shader() {
        use crate::nodes::shader::ShaderConfig;
        use crate::project::FrameId;
        let shader_state = crate::nodes::shader::ShaderState::new(FrameId::default());
        let detail = NodeDetail {
            path: LpPathBuf::from("/src/shader.shader"),
            config: Box::new(ShaderConfig::default()),
            state: NodeState::Shader(shader_state),
        };
        let serializable = detail.to_serializable().unwrap();
        match serializable {
            SerializableNodeDetail::Shader {
                path,
                config: _,
                state,
            } => {
                assert_eq!(path.as_str(), "/src/shader.shader");
                assert!(matches!(state, NodeState::Shader(_)));
            }
            _ => panic!("Expected Shader variant"),
        }
    }

    #[test]
    fn test_project_response_to_serializable() {
        use crate::nodes::texture::TextureConfig;
        let mut node_details = BTreeMap::new();
        node_details.insert(
            NodeHandle::new(1),
            NodeDetail {
                path: LpPathBuf::from("/src/texture.texture"),
                config: Box::new(TextureConfig {
                    width: 100,
                    height: 200,
                }),
                state: {
                    use crate::project::FrameId;
                    let mut tex_state =
                        crate::nodes::texture::TextureState::new(FrameId::default());
                    tex_state
                        .texture_data
                        .set(FrameId::default(), vec![0, 1, 2, 3]);
                    tex_state.width.set(FrameId::default(), 2);
                    tex_state.height.set(FrameId::default(), 2);
                    tex_state
                        .format
                        .set(FrameId::default(), TextureFormat::Rgba16);
                    NodeState::Texture(tex_state)
                },
            },
        );

        let response = ProjectResponse::GetChanges {
            current_frame: FrameId::default(),
            since_frame: FrameId::default(),
            node_handles: vec![NodeHandle::new(1)],
            node_changes: vec![],
            node_details,
            theoretical_fps: None,
        };

        let serializable = response.to_serializable().unwrap();
        match serializable {
            SerializableProjectResponse::GetChanges {
                current_frame,
                since_frame: _,
                node_handles,
                node_changes,
                node_details,
                theoretical_fps: _,
            } => {
                assert_eq!(current_frame, FrameId::default());
                assert_eq!(node_handles.len(), 1);
                assert_eq!(node_changes.len(), 0);
                assert_eq!(node_details.len(), 1);
                assert!(
                    node_details
                        .iter()
                        .any(|(handle, _)| *handle == NodeHandle::new(1))
                );
            }
        }
    }

    #[test]
    fn test_serializable_node_detail_serialization() {
        use crate::nodes::texture::TextureConfig;
        use crate::project::FrameId;
        let mut tex_state = crate::nodes::texture::TextureState::new(FrameId::default());
        tex_state
            .texture_data
            .set(FrameId::default(), vec![0, 1, 2, 3]);
        tex_state.width.set(FrameId::default(), 2);
        tex_state.height.set(FrameId::default(), 2);
        tex_state
            .format
            .set(FrameId::default(), TextureFormat::Rgba16);
        let detail = SerializableNodeDetail::Texture {
            path: LpPathBuf::from("/src/texture.texture"),
            config: TextureConfig {
                width: 100,
                height: 200,
            },
            state: NodeState::Texture(tex_state),
        };
        let json = crate::json::to_string(&detail).unwrap();
        let deserialized: SerializableNodeDetail = crate::json::from_str(&json).unwrap();
        match deserialized {
            SerializableNodeDetail::Texture {
                path,
                config,
                state: _,
            } => {
                assert_eq!(path.as_str(), "/src/texture.texture");
                assert_eq!(config.width, 100);
                assert_eq!(config.height, 200);
            }
            _ => panic!("Expected Texture variant"),
        }
    }

    #[test]
    #[ignore] // TODO: Fix deserialization to match custom serialization format
    fn test_serializable_project_response_serialization() {
        use crate::nodes::texture::TextureConfig;
        let mut node_details = Vec::new();
        node_details.push((
            NodeHandle::new(1),
            SerializableNodeDetail::Texture {
                path: LpPathBuf::from("/src/texture.texture"),
                config: TextureConfig {
                    width: 100,
                    height: 200,
                },
                state: {
                    use crate::project::FrameId;
                    let mut tex_state =
                        crate::nodes::texture::TextureState::new(FrameId::default());
                    tex_state
                        .texture_data
                        .set(FrameId::default(), vec![0, 1, 2, 3]);
                    tex_state.width.set(FrameId::default(), 2);
                    tex_state.height.set(FrameId::default(), 2);
                    tex_state
                        .format
                        .set(FrameId::default(), TextureFormat::Rgba16);
                    NodeState::Texture(tex_state)
                },
            },
        ));

        let response = SerializableProjectResponse::GetChanges {
            current_frame: FrameId::default(),
            since_frame: FrameId::default(),
            node_handles: vec![NodeHandle::new(1)],
            node_changes: vec![],
            node_details,
            theoretical_fps: None,
        };

        let json = crate::json::to_string(&response).unwrap();
        let deserialized: SerializableProjectResponse = crate::json::from_str(&json).unwrap();
        match deserialized {
            SerializableProjectResponse::GetChanges {
                current_frame,
                since_frame: _,
                node_handles,
                node_changes,
                node_details,
                theoretical_fps: _,
            } => {
                assert_eq!(current_frame, FrameId::default());
                assert_eq!(node_handles.len(), 1);
                assert_eq!(node_changes.len(), 0);
                assert_eq!(node_details.len(), 1);
            }
        }
    }
}
