# Design Questions: Output Provider System

## Current State

- **Current OutputRuntime**: Has a `channel_data: Vec<u8>` buffer that fixtures write to via `get_buffer_mut()`
- **Old Engine Pattern**: Used `OutputProvider` trait with `create_output()` returning `Box<dyn LedOutput>`, where `LedOutput` had `write_pixels(&[u8])` and `get_pixel_count()`
- **Current Gap**: No actual output provider system, outputs just accumulate data in buffers. No flushing to hardware.

## Goal

Design a provider/driver system for outputs that:
- Has API: `open(pin, byte_count, format)` -> `Result<OutputChannelHandle>`
- Has API: `write(handle, &[u8])` -> `Result<()>`
- Has API: `close(handle)` -> `Result<()>`
- Supports in-memory implementation for testing (tracks opened outputs, prevents duplicates)
- Supports ESP32 hardware implementation (future - will start underlying driver)
- Integrates with ProjectRuntime (passed in, maybe Arc for sharing)
- Updates end-to-end test to verify data flows to memory output

## Questions

### 1. API Semantics: `open(pin, length, format)` ✅ **ANSWERED**

**Question**: What do the parameters mean?

- **`pin`**: GPIO pin number (u32) - for consistency with OutputConfig. In the future, more complex output identifiers will be supported.

- **`length`**: What does this represent?
  - Option A: Number of pixels/LEDs (e.g., 128 LEDs)
  - Option B: Number of channels/bytes (e.g., 128 * 3 = 384 bytes for RGB)
  - Option C: Something else?
  
  The old code had `pixel_count` and `bytes_per_pixel`, suggesting length might be pixel count, and format determines bytes per pixel.

- **`format`**: Should this be an enum? For now only `ws2811` (or `ws2812`), but extensible? Does format determine bytes-per-pixel (ws2811 = 3 bytes RGB)?

**Suggested approach**: 
- `pin` = GPIO pin number (u32) ✅
- `length` = pixel/LED count (u32) - **needs confirmation**
- `format` = enum `OutputFormat::Ws2811` (determines bytes-per-pixel = 3) - **needs confirmation**
- Provider calculates total bytes needed: `length * format.bytes_per_pixel()`

**Current state**: OutputConfig has `pin: u32` but no `count` or `format` field yet. We may need to add these to OutputConfig, or derive from existing data.

---

### 2. Length and Format Parameters ✅ **ANSWERED**

**Question**: What should `length` and `format` represent?

**Answer**:
- `byte_count` (or similar name) = total bytes (u32) - e.g., 384 bytes for 128 RGB LEDs
- At provider level, we deal with raw bytes, not semantic concepts like pixels
- `format` = enum `OutputFormat` with only `Ws2811` variant for now
- Format determines protocol/timing, not bytes-per-pixel (that's handled at higher level)

**API**: `open(pin: u32, byte_count: u32, format: OutputFormat) -> Result<OutputChannelHandle>`

---

### 3. OutputHandle Type ✅ **ANSWERED**

**Question**: What should the provider handle type be?

**Answer**:
- `OutputChannelHandle` = newtype wrapper: `pub struct OutputChannelHandle(i32)`
- Allows -1 to represent None/invalid handle
- Provider maintains `BTreeMap<OutputChannelHandle, OutputState>` internally
- Handles are generated by provider (incrementing counter, starting from 0 or 1)
- **Note**: Named `OutputChannelHandle` to distinguish from `OutputHandle` in `contexts.rs` (which wraps `NodeHandle` for node resolution)

---

### 4. Provider Ownership and Integration ✅ **ANSWERED**

**Question**: How should the provider be owned and passed to ProjectRuntime?

**Answer**:
- Store `Arc<dyn OutputProvider>` in `ProjectRuntime` for sharing
- Pass to `NodeInitContext` so `OutputRuntime::init()` can call `open()`
- Pass to `RenderContext` so `OutputRuntime::render()` can call `write()`
- Allows multiple runtimes to share provider without cloning
- For now, this approach works

---

### 5. OutputRuntime Integration ✅ **ANSWERED**

**Question**: How should OutputRuntime integrate with the provider?

**Answer**:
- `OutputRuntime::init()`:
  - Extract `pin`, `byte_count` (from config or calculate), `format` from `OutputConfig`
  - Call `ctx.output_provider().open(pin, byte_count, format)` to get `OutputChannelHandle`
  - Store handle in `OutputRuntime` (e.g., `channel_handle: Option<OutputChannelHandle>`)
  - Allocate `channel_data` buffer of size `byte_count`
- `OutputRuntime::render()`:
  - Call `ctx.output_provider().write(channel_handle, &channel_data)` to flush to hardware
- `OutputRuntime::destroy()`:
  - Call `ctx.output_provider().close(channel_handle)` to clean up

**Note**: Need to add `output_provider()` methods to `NodeInitContext` and `RenderContext` traits.

---
