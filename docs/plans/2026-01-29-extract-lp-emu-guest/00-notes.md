# Extract lp-riscv-emu-guest Crate - Notes

## Scope of Work

Extract the RISC-V32 emulator guest code from `lp-glsl/lp-glsl-builtins-emu-app` into a new
common crate
`lp-glsl/lp-riscv-emu-guest`. This guest code provides the runtime foundation for code
running in the RISC-V emulator and needs to be reusable by firmware and other applications.

The extracted code includes:

- Entry point and bootstrap code (`_entry`, `_code_entry`)
- Panic handler with syscall reporting
- Syscall implementation for host communication
- Host communication functions (`__host_debug`, `__host_println`)
- Print macros and writer for no_std environments
- Builtin reference system (to prevent dead code elimination)

## Current State

### Source Location

The guest code currently lives in `lp-glsl/lp-glsl-builtins-emu-app/src/`:

- `main.rs` - Entry point, panic handler, syscall implementation, bootstrap code
- `host.rs` - Host communication functions (debug, println syscalls)
- `print.rs` - Print macros and writer implementation
- `builtin_refs.rs` - Auto-generated references to builtin functions

### Dependencies

- `lp-glsl-builtins` crate - Provides builtin functions that need to be referenced
- `memory.ld` - Linker script for memory layout (ROM/RAM sections, stack, heap)
- `build.rs` - Build script that links the memory.ld script

### Usage

- `lp-glsl-builtins-emu-app` currently uses this code as its main binary
- `lp-glsl-compiler` builds `lp-glsl-builtins-emu-app` and embeds it as a library
- Future firmware (`fw-emu`) will need this guest code to run firmware in the emulator

### Build Configuration

- Target: `riscv32imac-unknown-none-elf`
- Features: `no_std`, `no_main`
- Uses custom linker script (`memory.ld`)
- Excluded from default workspace builds (only builds for RISC-V target)

## Questions

### Q1: Crate Structure - Library vs Binary

**Question**: Should `lp-riscv-emu-guest` be a library crate that provides functions/modules, or
should it also provide a binary entry point?

**Context**:

- The current code has `#![no_main]` and provides `_entry` and `_code_entry` functions
- `lp-glsl-builtins-emu-app` needs to use this code as its main binary
- Future firmware will also need to use this guest code
- The entry point code (`_entry`, `_code_entry`) is generic and reusable

**Suggested Answer**: Make `lp-riscv-emu-guest` a library crate that provides:

- Public modules for syscalls, host communication, print macros
- Public functions for entry point (`_entry`, `_code_entry`) that can be called from a binary
- The binary (`lp-glsl-builtins-emu-app`) will become a thin wrapper that calls these functions

**Answer**: Agreed. `lp-riscv-emu-guest` will be a library crate with public modules and functions.
`lp-glsl-builtins-emu-app` becomes a thin wrapper.

---

### Q2: Linker Script Location

**Question**: Should `memory.ld` be part of `lp-riscv-emu-guest` crate or remain in the
application (`lp-glsl-builtins-emu-app`)?

**Context**:

- `memory.ld` defines memory layout (ROM, RAM, stack, heap)
- Different applications might need different memory layouts
- However, the current layout seems appropriate for emulator use cases
- The linker script is referenced in `build.rs`

**Suggested Answer**: Include `memory.ld` in `lp-riscv-emu-guest` crate. Applications can override
it if needed, but the default should work for most emulator use cases. The crate's `build.rs` will
set up the linker script.

**Answer**: Agreed. `memory.ld` will be included in `lp-riscv-emu-guest` crate with the crate's
`build.rs` setting it up.

---

### Q3: Builtin References Generation

**Question**: How should `builtin_refs.rs` be handled? Should it be generated as part of the crate,
or remain app-specific?

**Context**:

- `builtin_refs.rs` is auto-generated by `lp-glsl-builtin-gen-app`
- It references all builtin functions to prevent dead code elimination
- `lp-glsl-builtins-emu-app` needs this to ensure builtins are included
- Future firmware might not need all builtins, or might need different ones

**Suggested Answer**: Make builtin references optional via a feature flag. The crate can provide a
default implementation that references all builtins, but allow applications to provide their own
`builtin_refs` module if they need custom behavior. For `lp-glsl-builtins-emu-app`, we'll use the
default.

**Answer**: Builtin references are app-specific. `lp-riscv-emu-guest` will NOT include
`builtin_refs.rs`. Each application (`lp-glsl-builtins-emu-app`, firmware, etc.) will provide its
own
`builtin_refs` module if needed.

---

### Q4: Public API Design

**Question**: What should be the public API of `lp-riscv-emu-guest`? Should all modules be public,
or should there be a more controlled API surface?

**Context**:

- `syscall`, `panic_syscall`, `ebreak` are internal implementation details
- `__host_debug`, `__host_println` need to be public (used by macros)
- `_entry`, `_code_entry` need to be public (called from binary)
- Print macros (`print!`, `println!`) should be re-exported

**Suggested Answer**:

- Public modules: `host`, `print` (for macros)
- Public functions: `_entry`, `_code_entry` (via `#[no_mangle]`)
- Re-export macros: `print!`, `println!`, `host_debug!`, `host_println!`
- Internal: `syscall`, `panic_syscall`, `ebreak` (keep as `pub(crate)` or private)

**Answer**: Agreed. Public API will expose `host` and `print` modules, entry point functions, and
re-export macros. Internal implementation details will be private.

---

### Q5: Feature Flags

**Question**: Should `lp-riscv-emu-guest` have feature flags for optional components?

**Context**:

- All current functionality seems essential for emulator guest code
- Future might need optional components (e.g., different panic handlers, different syscall
  implementations)

**Suggested Answer**: Start without feature flags. Add them later if needed. Keep the API simple
initially.

**Answer**: Agreed. No feature flags for now. Keep it simple.

---

### Q6: lp-glsl-builtins-emu-app Refactoring

**Question**: After extraction, what should `lp-glsl-builtins-emu-app` become? A thin binary
wrapper, or
should it be removed entirely?

**Context**:

- `lp-glsl-builtins-emu-app` is currently built and embedded by `lp-glsl-compiler`
- It serves as a way to link all builtins into a static library
- The binary needs to call `_lp_main()` which references builtins

**Suggested Answer**: `lp-glsl-builtins-emu-app` becomes a thin binary that:

- Depends on `lp-riscv-emu-guest`
- Provides `_lp_main()` function that references builtins (this is app-specific)
- Calls the entry point from `lp-riscv-emu-guest`
- Can be simplified significantly since most code moves to the crate

**Answer**: Agreed. `lp-glsl-builtins-emu-app` will become a thin binary wrapper that depends on
`lp-riscv-emu-guest` and provides the app-specific `_lp_main()` function.
