# Emulator Crash Report: UnalignedAccess / InvalidMemoryAccess in test_scene_render_fw_emu

**Date:** 2026-02-28  
**Test:** `RUST_LOG=debug cargo test -p fw-tests test_scene_render_fw_emu -- --nocapture`  
**Status:** Fixed (workspace profile revert)

---

## Executive Summary

The integration test `test_scene_render_fw_emu` crashes when `fw-emu` is built with workspace-level `opt-level = "z"` and `codegen-units = 1` in `Cargo.toml`'s `[profile.release]`. These settings were added in commit 88eb565 for embedded size optimization. With them enabled, Cranelift (used for RISC-V shader code generation) produces faulty machine code, causing the RISC-V emulator to hit memory access errors during execution.

**Fix:** Comment out the workspace-level `opt-level` and `codegen-units` lines in `Cargo.toml`. Per-package overrides for `esp32-glsl-jit` and `fw-esp32` retain size optimization for embedded targets.

---

## Root Cause

### Technical Details

The offending commit (88eb565) added to `Cargo.toml`:

```toml
[profile.release]
lto = true
opt-level = "z"      # Aggressive size optimization
codegen-units = 1    # Single codegen unit for whole-program optimization
```

These settings apply to **all** workspace packages that do not have their own `[profile.release.package.<name>]` override. The `fw-emu` crate (RISC-V firmware run in the emulator) had no override, so it inherited these settings. Its dependency chain includes:

- `lp-server` → `lp-engine` → `lp-glsl-compiler` → Cranelift (codegen, frontend, etc.)

When building `fw-emu` in release mode for `riscv32imac-unknown-none-elf`, Cranelift is compiled and used to generate RISC-V machine code from GLSL shaders. With `opt-level = "z"` and `codegen-units = 1`:

1. **opt-level "z"**: Optimize for minimum size. This can trigger aggressive optimizations (e.g., more inlining, different instruction selection, tail merging) that expose bugs or produce incorrect code under edge cases.

2. **codegen-units = 1**: Single compilation unit. Enables more cross-module optimization and inlining. Can change code layout and instruction sequences in ways that interact badly with the codebase.

The observed failures:

- **UnalignedAccess**: Guest RISC-V code performs a load/store at a misaligned address that the emulator rejects (or the generated code uses an incorrect address).
- **InvalidMemoryAccess (InstructionFetch)**: Guest code jumps to an invalid address (e.g., `0xfc942222` or `0x2823e794`). The PC value is a data value (e.g., from a vtable or function pointer) being used as a code address—indicating wrong code generation (e.g., incorrect relocation, wrong pointer use, or optimization-induced corruption).

---

## Commit History

### Offending Commit

| Hash | Message |
|------|---------|
| **88eb565bd8be4eaaf0047eb78f335a68a805722e** | chore(fw-esp32): add linker flags to merge sections for bootloader compatibility |

This commit added workspace-level `opt-level = "z"` and `codegen-units = 1`, along with other changes (cranelift path deps, cranelift-optimizer/verifier feature gating, esp-println submodule, etc.). The profile settings were the cause of the emulator crash.

### Bisect Reference (First Branch)

- **Known good:** `f5d0998ac68dc3af3376cca2c63a00288f3e422f`
- **Known bad:** `dd0ab58`
- **Notes directory:** `/Users/yona/dev/photomancer/notes/2026-02-27-emu-crash`
- **History rewrite worktree:** `feature/fix-emu-rewrite`

`fw-tests` was not in `default-members`, so it was not built/run for a period. Standard `git bisect` was difficult because the test did not compile on many commits due to refactors. The approach: replay history one commit at a time, fixing build-blocking issues as needed, to find the bad commit. Fix commits were prefixed with `EMU-FIX` in the message for easy identification.

### Bisect Reference (Second Branch: feature/fix-emu-rewrite2)

Created to narrow down the first UnalignedAccess:

| Commit | Result |
|--------|--------|
| **237faf6** | Pass |
| **c4f0101** | Pass |
| **8ae32cb** | Other (build/test issue) |
| **042ff4a** | UnalignedAccess |

Branch `feature/fix-emu-rewrite2` was set to 237faf6 (last known good).

### Check Script and Logs

A `check.sh` script was created at:

```
/Users/yona/dev/photomancer/notes/2026-02-27-emu-crash/scripts/check.sh
```

Behavior:

1. Runs `RUST_LOG=debug cargo test -p fw-tests test_scene_render_fw_emu -- --nocapture`
2. Logs output to `check-log/YYYY-MM-DD-nnmmss-HASH-<RESULT>.txt`
3. Writes commit hash to `check-log/{Pass,InvalidMemoryAccess,BuildError}.txt`
4. Returns: Pass (0), InvalidMemoryAccess (non-zero), or BuildError (non-zero)
5. Skips logging if there are local git changes (prompts user to confirm)

Example log files from the second branch:

- `2026-02-28-140028-237faf6-Pass.txt`
- `2026-02-28-140220-c4f0101-Other.txt`
- `2026-02-28-140315-8ae32cb-Other.txt`
- `2026-02-28-140732-042ff4a-UnalignedAccess.txt`

---

## The Fix

### Applied Change

In `Cargo.toml`:

```toml
[profile.release]
# Link-time optimization for all release builds - saves ~100-300 KB
lto = true
# Revert of 88eb565: Workspace-level opt-level="z" and codegen-units=1 cause
# memory/codegen bugs (InvalidMemoryAccess, UnalignedAccess) in test_scene_render_fw_emu.
# Per-package overrides (esp32-glsl-jit, fw-esp32) retain size optimization for embedded.
# opt-level = "z"
# codegen-units = 1
```

The two lines are commented out. Cargo then uses release defaults: `opt-level = 3`, `codegen-units = 16`.

### What Stays Optimized

Packages with `[profile.release.package.<name>]` overrides keep their settings:

- **esp32-glsl-jit**: `opt-level = "z"`, `codegen-units = 1` (embedded size)
- **fw-esp32**: `opt-level = "z"`, `codegen-units = 1` (embedded size)
- **lp-engine**: `opt-level = 3`, `codegen-units = 4` (speed)
- **lp-glsl-builtins**: `opt-level = 3`, `codegen-units = 4` (speed)
- **fw-emu**: `debug = 1` only (for backtrace symbolication)

---

## Re-enabling the Flags (Future Considerations)

If you want to re-enable `opt-level = "z"` and `codegen-units = 1` at the workspace level:

### Option 1: Exclude fw-emu

Add an override so `fw-emu` uses less aggressive optimization:

```toml
[profile.release.package.fw-emu]
opt-level = 3
codegen-units = 4
debug = 1
```

**Note:** During investigation, this override led to `InvalidMemoryAccess` (InstructionFetch) instead of `UnalignedAccess`. The workspace-wide revert was the reliable fix.

### Option 2: Narrow Scope

Avoid workspace-level settings. Apply size optimization only to embedded targets via existing per-package overrides.

### Option 3: Cranelift / Compiler Debugging

If workspace-level flags are required:

1. Enable Cranelift verifier for fw-emu:  
   `lp-server = { ..., features = ["cranelift-verifier"] }`  
   (Catches some IR bugs before codegen; may not catch all miscompilations.)
2. Bisect Cranelift optimization passes to find which pass introduces the bug.
3. Report upstream to lp-cranelift if a specific optimization is at fault.
4. Consider using `opt-level = "s"` instead of `"z"` as a milder size/behavior tradeoff.

### Verification

After any change, run:

```bash
RUST_LOG=debug cargo test -p fw-tests test_scene_render_fw_emu -- --nocapture
```

The test must complete without `UnalignedAccess` or `InvalidMemoryAccess`.

---

## Related Artifacts

- **Notes directory:** `/Users/yona/dev/photomancer/notes/2026-02-27-emu-crash`
- **Commit log (for replay):** `/Users/yona/dev/photomancer/notes/2026-02-27-emu-crash/commit-log/commits.txt`
- **Apply script:** `/Users/yona/dev/photomancer/notes/2026-02-27-emu-crash/commit-log/apply-next-commit.sh` for replaying commits with conflict handling
- **Bisect branches:** `feature/fix-emu-rewrite`, `feature/fix-emu-rewrite2`

---

## Post-Fix Note: Assertion Failure

After applying the revert, the test no longer crashes but may fail with:

```
assertion `left == right` failed: Output channel 0 R: expected 1, got 0 (data: [0, 0, 0])
```

This appears to be a separate issue (output value or frame sync) and should be investigated independently. The crash fix is independent of this assertion.
