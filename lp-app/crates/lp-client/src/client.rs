//! Client struct for communicating with LpServer

extern crate alloc;

use crate::error::ClientError;
use alloc::{
    collections::BTreeMap,
    format,
    string::{String, ToString},
    vec::Vec,
};
use lp_model::{
    ClientMessage, ClientRequest, Message, ServerMessage,
    project::{
        FrameId,
        api::{ApiNodeSpecifier, SerializableProjectResponse},
        handle::ProjectHandle,
    },
    server::{AvailableProject, FsRequest, FsResponse, LoadedProject, ServerResponse},
};

/// Pending request waiting for a response
struct PendingRequest {
    /// Request type description (for debugging)
    _request_type: String,
    /// Response when received (None until response arrives)
    response: Option<ServerResponse>,
}

/// Client for communicating with LpServer
///
/// Uses a tick-based API similar to game engines, processing incoming messages
/// and generating outgoing requests. The client manages request/response correlation
/// internally and provides blocking convenience methods for filesystem operations.
pub struct LpClient {
    /// Next request ID to use
    next_request_id: u64,
    /// Map of request ID -> pending request
    pending_requests: BTreeMap<u64, PendingRequest>,
}

impl LpClient {
    /// Create a new LpClient
    pub fn new() -> Self {
        Self {
            next_request_id: 1,
            pending_requests: BTreeMap::new(),
        }
    }

    /// Process incoming messages and generate outgoing requests
    ///
    /// This is the main entry point for processing server responses. It matches
    /// responses to pending requests and returns any outgoing request messages
    /// that were queued by blocking operations.
    ///
    /// # Arguments
    ///
    /// * `incoming` - Vector of incoming messages from the server
    ///
    /// # Returns
    ///
    /// * `Ok(Vec<Message>)` - Vector of outgoing request messages (all `Message::Client` variants)
    /// * `Err(ClientError)` - If processing failed
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use lp_model::Message;
    /// use lp_client::LpClient;
    ///
    /// # let mut client = LpClient::new();
    /// let incoming = vec![/* server messages */];
    /// let outgoing = client.tick(incoming).unwrap();
    /// ```
    pub fn tick(&mut self, incoming: Vec<Message>) -> Result<Vec<Message>, ClientError> {
        for message in incoming {
            match message {
                Message::Server(ServerMessage { id, msg }) => {
                    // Match response to pending request
                    if let Some(pending) = self.pending_requests.get_mut(&id) {
                        pending.response = Some(msg);
                    }
                }
                Message::Client(_) => {
                    // Client messages shouldn't be received by client
                    return Err(ClientError::Protocol {
                        message: "Received client message on client side".to_string(),
                    });
                }
            }
        }

        // Outgoing messages are generated by calling create_request() methods
        // They are returned directly, not queued here
        Ok(Vec::new())
    }

    /// Create a request message and add it to pending requests
    ///
    /// Returns the request message that should be sent and the request ID
    /// for tracking the response.
    fn create_request(&mut self, request: ClientRequest, request_type: &str) -> (Message, u64) {
        let request_id = self.next_request_id;
        self.next_request_id = self.next_request_id.wrapping_add(1);

        // Create pending request entry
        self.pending_requests.insert(
            request_id,
            PendingRequest {
                _request_type: request_type.to_string(),
                response: None,
            },
        );

        // Create client message
        let client_msg = ClientMessage {
            id: request_id,
            msg: request,
        };

        (Message::Client(client_msg), request_id)
    }

    /// Check if a pending request has received a response
    ///
    /// Returns the response if available, removing it from pending requests.
    /// Made public for testing purposes.
    pub fn get_response(&mut self, request_id: u64) -> Option<ServerResponse> {
        if let Some(pending) = self.pending_requests.get(&request_id) {
            if pending.response.is_some() {
                // Got response, remove from pending and return
                let pending = self.pending_requests.remove(&request_id).unwrap();
                return Some(pending.response.unwrap());
            }
        }
        None
    }

    /// Read a file from the server filesystem
    ///
    /// Creates a read request and returns the message to send and request ID
    /// for tracking the response.
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the file (relative to server root)
    ///
    /// # Returns
    ///
    /// * `(Message, u64)` - Request message to send and request ID for tracking
    pub fn fs_read(&mut self, path: String) -> (Message, u64) {
        let request = ClientRequest::Filesystem(FsRequest::Read { path: path.clone() });
        self.create_request(request, "fs_read")
    }

    /// Extract read response from a server response
    pub fn extract_read_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<Vec<u8>, ClientError> {
        match response {
            ServerResponse::Filesystem(FsResponse::Read { path, data, error }) => {
                if let Some(err_msg) = error {
                    Err(ClientError::Protocol {
                        message: format!("Server error reading {}: {}", path, err_msg),
                    })
                } else if let Some(data) = data {
                    Ok(data)
                } else {
                    Err(ClientError::Protocol {
                        message: format!("Server returned no data for {}", path),
                    })
                }
            }
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for fs_read".to_string(),
            }),
        }
    }

    /// Write a file to the server filesystem
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn fs_write(&mut self, path: String, data: Vec<u8>) -> (Message, u64) {
        let request = ClientRequest::Filesystem(FsRequest::Write {
            path: path.clone(),
            data,
        });
        self.create_request(request, "fs_write")
    }

    /// Extract write response from a server response
    pub fn extract_write_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<(), ClientError> {
        match response {
            ServerResponse::Filesystem(FsResponse::Write { path, error }) => {
                if let Some(err_msg) = error {
                    Err(ClientError::Protocol {
                        message: format!("Server error writing {}: {}", path, err_msg),
                    })
                } else {
                    Ok(())
                }
            }
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for fs_write".to_string(),
            }),
        }
    }

    /// Delete a file from the server filesystem
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn fs_delete_file(&mut self, path: String) -> (Message, u64) {
        let request = ClientRequest::Filesystem(FsRequest::DeleteFile { path: path.clone() });
        self.create_request(request, "fs_delete_file")
    }

    /// Extract delete file response from a server response
    pub fn extract_delete_file_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<(), ClientError> {
        match response {
            ServerResponse::Filesystem(FsResponse::DeleteFile { path, error }) => {
                if let Some(err_msg) = error {
                    Err(ClientError::Protocol {
                        message: format!("Server error deleting file {}: {}", path, err_msg),
                    })
                } else {
                    Ok(())
                }
            }
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for fs_delete_file".to_string(),
            }),
        }
    }

    /// Delete a directory from the server filesystem (recursive)
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn fs_delete_dir(&mut self, path: String) -> (Message, u64) {
        let request = ClientRequest::Filesystem(FsRequest::DeleteDir { path: path.clone() });
        self.create_request(request, "fs_delete_dir")
    }

    /// Extract delete directory response from a server response
    pub fn extract_delete_dir_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<(), ClientError> {
        match response {
            ServerResponse::Filesystem(FsResponse::DeleteDir { path, error }) => {
                if let Some(err_msg) = error {
                    Err(ClientError::Protocol {
                        message: format!("Server error deleting directory {}: {}", path, err_msg),
                    })
                } else {
                    Ok(())
                }
            }
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for fs_delete_dir".to_string(),
            }),
        }
    }

    /// List directory contents from the server filesystem
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn fs_list_dir(&mut self, path: String, recursive: bool) -> (Message, u64) {
        let request = ClientRequest::Filesystem(FsRequest::ListDir {
            path: path.clone(),
            recursive,
        });
        self.create_request(request, "fs_list_dir")
    }

    /// Extract list directory response from a server response
    pub fn extract_list_dir_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<Vec<String>, ClientError> {
        match response {
            ServerResponse::Filesystem(FsResponse::ListDir {
                path,
                entries,
                error,
            }) => {
                if let Some(err_msg) = error {
                    Err(ClientError::Protocol {
                        message: format!("Server error listing directory {}: {}", path, err_msg),
                    })
                } else {
                    Ok(entries)
                }
            }
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for fs_list_dir".to_string(),
            }),
        }
    }

    /// Load a project on the server
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn project_load(&mut self, path: String) -> (Message, u64) {
        let request = ClientRequest::LoadProject { path };
        self.create_request(request, "project_load")
    }

    /// Extract load project response from a server response
    pub fn extract_load_project_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<ProjectHandle, ClientError> {
        match response {
            ServerResponse::LoadProject { handle } => Ok(handle),
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for project_load".to_string(),
            }),
        }
    }

    /// Unload a project on the server
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn project_unload(&mut self, handle: ProjectHandle) -> (Message, u64) {
        let request = ClientRequest::UnloadProject { handle };
        self.create_request(request, "project_unload")
    }

    /// Extract unload project response from a server response
    pub fn extract_unload_project_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<(), ClientError> {
        match response {
            ServerResponse::UnloadProject => Ok(()),
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for project_unload".to_string(),
            }),
        }
    }

    /// Send a GetChanges request to a project
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn project_get_changes(
        &mut self,
        handle: ProjectHandle,
        since_frame: FrameId,
        detail_specifier: ApiNodeSpecifier,
    ) -> (Message, u64) {
        let request = ClientRequest::ProjectRequest {
            handle,
            request: lp_model::project::api::ProjectRequest::GetChanges {
                since_frame,
                detail_specifier,
            },
        };
        self.create_request(request, "project_get_changes")
    }

    /// Extract get changes response from a server response
    pub fn extract_get_changes_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<SerializableProjectResponse, ClientError> {
        match response {
            ServerResponse::ProjectRequest { response } => Ok(response),
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for project_get_changes".to_string(),
            }),
        }
    }

    /// List available projects on the server filesystem
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn project_list_available(&mut self) -> (Message, u64) {
        let request = ClientRequest::ListAvailableProjects;
        self.create_request(request, "project_list_available")
    }

    /// Extract list available projects response from a server response
    pub fn extract_list_available_projects_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<Vec<AvailableProject>, ClientError> {
        match response {
            ServerResponse::ListAvailableProjects { projects } => Ok(projects),
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for project_list_available".to_string(),
            }),
        }
    }

    /// List loaded projects on the server
    ///
    /// Returns the request message and request ID for tracking the response.
    pub fn project_list_loaded(&mut self) -> (Message, u64) {
        let request = ClientRequest::ListLoadedProjects;
        self.create_request(request, "project_list_loaded")
    }

    /// Extract list loaded projects response from a server response
    pub fn extract_list_loaded_projects_response(
        &mut self,
        _request_id: u64,
        response: ServerResponse,
    ) -> Result<Vec<LoadedProject>, ClientError> {
        match response {
            ServerResponse::ListLoadedProjects { projects } => Ok(projects),
            _ => Err(ClientError::Protocol {
                message: "Unexpected response type for project_list_loaded".to_string(),
            }),
        }
    }
}
